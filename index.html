<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>í”„ë¦¬ë¯¸ì—„ ê²Œì„ ì„¼í„°</title>
  <style>
    :root { 
      --bg:#070a0f; --card:rgba(17, 24, 38, 0.95); --text:#e6eef9; --accent:#6ee7ff; --line:#2b3b55;
    }
    body { 
      margin:0; font-family: sans-serif; background: var(--bg); color: var(--text);
      display: flex; flex-direction: column; align-items: center;
    }

    /* ê²Œì„ ì»¨í…Œì´ë„ˆ */
    #gamePage { width: 100%; max-width: 1000px; padding: 20px; text-align: center; }
    
    .preset-btns { display: flex; gap: 10px; justify-content: center; margin: 30px 0; }
    .img-btn {
      background-color: #1e293b; border: 1px solid var(--accent); color: white;
      padding: 12px 20px; border-radius: 50px; cursor: pointer; font-weight: bold;
    }

    /* ì‚¬ë‹¤ë¦¬ í”„ë ˆì„: ì…ë ¥ì°½ê³¼ ìº”ë²„ìŠ¤ì˜ ë„ˆë¹„ë¥¼ 800pxë¡œ ê³ ì • */
    .ladder-frame { 
      position: relative; 
      width: 800px; /* ê³ ì • ë„ˆë¹„ */
      margin: 40px auto; 
    }
    
    /* í•­ëª©ì¹¸(Input) ì •ë ¬ í•µì‹¬ */
    .label-grid { 
      display: flex; 
      width: 100%; 
      justify-content: space-between; 
      margin: 10px 0;
    }
    .input-wrap {
      flex: 1; /* ë™ì¼í•œ ê³µê°„ í• ë‹¹ */
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .label-grid input { 
      width: 60px; background: #0c1422; color: white; border: 1px solid var(--line);
      padding: 8px 0; border-radius: 8px; text-align: center;
    }

    canvas { background: transparent; display: block; }

    /* ë§ ì„¤ì •: z-indexë¥¼ ë†’ì´ê³  translateë¥¼ í†µí•´ ì„  ì •ì¤‘ì•™ì— ë°°ì¹˜ */
    #playerPiece {
      position: absolute; width: 30px; height: 30px;
      background-image: url('https://cdn-icons-png.flaticon.com/128/802/802340.png');
      background-size: contain; background-repeat: no-repeat;
      display: none; z-index: 100; pointer-events: none;
      /* ìºë¦­í„° ì´ë¯¸ì§€ê°€ ì„  ìœ„ì— ì •í™•íˆ ê±¸ì¹˜ë„ë¡ -50% ì¡°ì • */
      transform: translate(-50%, -50%); 
    }

    .gen-btn {
      width: 250px; height: 60px; font-size: 20px; border-radius: 10px;
      background: var(--accent); color: #000; border: none; font-weight: bold; cursor: pointer;
    }
  </style>
</head>
<body>

  <div id="gamePage">
    <div id="ladderGame">
      <div class="preset-btns">
        <button class="img-btn" onclick="applyPreset('835', 5)">ğŸ˜ˆ 835 ğŸ˜ˆ</button>
        <button class="img-btn" onclick="applyPreset('1435', 5)">ğŸ‘¼ 1435 ğŸ‘¼</button>
        <button class="img-btn" onclick="applyPreset('3535', 4)">ğŸ‘ 3535 ğŸ‘</button>
        <button class="img-btn" onclick="applyPreset('18335', 3)">â¤ï¸ 18335 â¤ï¸</button>
      </div>

      <div class="ladder-frame">
        <div id="topInputs" class="label-grid"></div>
        
        <div style="position: relative; width: 800px; height: 500px;">
          <div id="playerPiece"></div>
          <canvas id="ladderCanvas" width="800" height="500"></canvas>
        </div>

        <div id="bottomInputs" class="label-grid"></div>
      </div>
      
      <button class="gen-btn" onclick="generateLadder()">ì‚¬ë‹¤ë¦¬ ìƒì„±</button>
    </div>
  </div>

<script>
  const canvas = document.getElementById('ladderCanvas');
  const ctx = canvas.getContext('2d');
  const piece = document.getElementById('playerPiece');
  let state = { n: 5, h: 15, links: [], isMoving: false };

  // í•µì‹¬: ì…ë ¥ì°½ì˜ ì¤‘ì‹¬ê³¼ ì‚¬ë‹¤ë¦¬ ì„ ì˜ ì¢Œí‘œë¥¼ ì™„ë²½í•˜ê²Œ ì¼ì¹˜ì‹œí‚´
  function getXPos(idx) {
    const totalWidth = canvas.width;
    const colWidth = totalWidth / state.n;
    // (í˜„ì¬ ì¹¸ì˜ ìœ„ì¹˜) + (ì¹¸ ë„ˆë¹„ì˜ ì ˆë°˜)
    return (idx * colWidth) + (colWidth / 2);
  }

  function applyPreset(name, count) {
    state.n = count;
    const topWrap = document.getElementById('topInputs');
    const botWrap = document.getElementById('bottomInputs');
    
    topWrap.innerHTML = ''; botWrap.innerHTML = '';
    for(let i=0; i<count; i++) {
      topWrap.innerHTML += `<div class="input-wrap"><input type="text" value="${i+1}" id="t${i}" onclick="startFrom(${i})"></div>`;
      botWrap.innerHTML += `<div class="input-wrap"><input type="text" value="?" id="b${i}"></div>`;
    }
    ctx.clearRect(0,0,canvas.width, canvas.height);
    state.links = [];
    drawStaticLines();
  }

  function drawStaticLines() {
    ctx.strokeStyle = "#2b3b55"; ctx.lineWidth = 3;
    for(let i=0; i<state.n; i++) {
      const x = getXPos(i);
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
    }
  }

  function generateLadder() {
    if(state.isMoving) return;
    state.links = Array.from({length: state.h}, () => []);
    for(let y=0; y<state.h; y++) {
      for(let x=0; x<state.n-1; x++) {
        if(Math.random() < 0.5) { state.links[y].push(x); x++; }
      }
    }
    renderAll();
  }

  function renderAll() {
    ctx.clearRect(0,0,canvas.width, canvas.height);
    drawStaticLines();
    const dy = canvas.height / (state.h + 1);
    ctx.strokeStyle = "#6ee7ff"; ctx.lineWidth = 4;
    state.links.forEach((row, y) => {
      const yy = (y + 1) * dy;
      row.forEach(x => {
        ctx.beginPath(); 
        ctx.moveTo(getXPos(x), yy); 
        ctx.lineTo(getXPos(x+1), yy); 
        ctx.stroke();
      });
    });
  }

  async function startFrom(colIdx) {
    if(state.links.length === 0 || state.isMoving) return;
    state.isMoving = true;
    
    const dy = canvas.height / (state.h + 1);
    let curCol = colIdx;
    let curX = getXPos(curCol);
    let curY = 0;

    piece.style.display = 'block';
    updatePiecePos(curX, curY);

    for(let y=0; y<state.h; y++) {
      // 1. ìˆ˜ì§ í•˜ê°•
      const targetY = (y + 1) * dy;
      await animatePiece(curX, targetY);
      curY = targetY;

      // 2. ìˆ˜í‰ ì´ë™ ì²´í¬
      let nextCol = curCol;
      if(state.links[y].includes(curCol)) {
        nextCol = curCol + 1;
      } else if(state.links[y].includes(curCol - 1)) {
        nextCol = curCol - 1;
      }

      if(nextCol !== curCol) {
        const nextX = getXPos(nextCol);
        await animatePiece(nextX, curY);
        curX = nextX;
        curCol = nextCol;
      }
    }

    // 3. ìµœì¢… ë°”ë‹¥ê¹Œì§€
    await animatePiece(curX, canvas.height);
    state.isMoving = false;
  }

  function updatePiecePos(x, y) {
    // ìº”ë²„ìŠ¤ ë‚´ì—ì„œì˜ ìƒëŒ€ ì¢Œí‘œë¡œ ë§ì˜ ìœ„ì¹˜ë¥¼ ê³ ì •
    piece.style.left = x + 'px';
    piece.style.top = y + 'px';
  }

  function animatePiece(tx, ty) {
    return new Promise(resolve => {
      const sx = parseFloat(piece.style.left), sy = parseFloat(piece.style.top);
      const startTime = performance.now();
      const duration = 150; 

      function step(now) {
        const p = Math.min((now - startTime) / duration, 1);
        updatePiecePos(sx + (tx - sx) * p, sy + (ty - sy) * p);
        if(p < 1) requestAnimationFrame(step); else resolve();
      }
      requestAnimationFrame(step);
    });
  }

  window.onload = () => applyPreset('835', 5);
</script>
</body>
</html>
