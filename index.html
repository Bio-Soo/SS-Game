<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ì»¤ìŠ¤í…€ ì‚¬ë‹¤ë¦¬ ê²Œì„</title>
  <style>
    :root { 
      --bg:#0b0f14; --card:#111826; --text:#e6eef9; --accent:#6ee7ff; --line:#2b3b55;
    }
    body { 
      margin:0; font-family: sans-serif; background: var(--bg); color: var(--text);
      display: flex; flex-direction: column; align-items: center; padding: 20px;
    }
    .container { max-width: 900px; width: 100%; text-align: center; }
    
    /* ê·œê²© ì„ íƒ ë²„íŠ¼ */
    .preset-btns { display: flex; gap: 10px; justify-content: center; margin-bottom: 20px; flex-wrap: wrap; }
    .preset-btns button { 
      padding: 10px 15px; background: #1e293b; border: 1px solid var(--accent); 
      color: white; border-radius: 8px; cursor: pointer; font-weight: bold;
    }
    .preset-btns button:hover { background: var(--accent); color: black; }

    /* ì‚¬ë‹¤ë¦¬ ì˜ì—­ */
    .ladder-frame { position: relative; margin: 20px 0; background: rgba(255,255,255,0.03); border-radius: 15px; padding: 20px; }
    canvas { background: transparent; display: block; margin: 0 auto; cursor: pointer; }

    /* ì…ë ¥ì°½ ê·¸ë¦¬ë“œ */
    .label-grid { display: grid; gap: 10px; margin: 10px 0; }
    .label-grid input { 
      width: 100%; background: #0c1422; color: white; border: 1px solid var(--line);
      padding: 8px; border-radius: 5px; text-align: center; font-size: 13px;
    }
    .label-grid input:focus { border-color: var(--accent); outline: none; }

    /* ì œì–´ ë²„íŠ¼ */
    .controls { margin-top: 20px; }
    .main-btn { 
      padding: 15px 40px; font-size: 18px; background: var(--accent); color: black;
      border: none; border-radius: 10px; cursor: pointer; font-weight: bold;
    }
    
    /* ì´ë™í•˜ëŠ” ë§ (ì´ë¯¸ì§€) */
    #playerPiece {
      position: absolute; width: 40px; height: 40px;
      background-image: url('https://cdn-icons-png.flaticon.com/128/802/802340.png'); /* ì´ë™í•˜ëŠ” ìºë¦­í„° ì´ë¯¸ì§€ */
      background-size: contain; background-repeat: no-repeat;
      display: none; z-index: 10; pointer-events: none;
      transform: translate(-50%, -100%); /* ë°œì´ ì„ ì— ë‹¿ê²Œ ì¡°ì • */
    }
  </style>
</head>
<body>

<div class="container">
  <h1>ğŸªœ ë§ì¶¤í˜• ì‚¬ë‹¤ë¦¬ ê²Œì„</h1>

  <div class="preset-btns">
    <button onclick="applyPreset('835', 5)">835 (5ê°œ)</button>
    <button onclick="applyPreset('1435', 5)">1435 (5ê°œ)</button>
    <button onclick="applyPreset('3535', 4)">3535 (4ê°œ)</button>
    <button onclick="applyPreset('18335', 3)">18335 (3ê°œ)</button>
  </div>

  <div class="ladder-frame">
    <div id="topInputs" class="label-grid"></div>
    
    <div style="position: relative;">
      <div id="playerPiece"></div>
      <canvas id="ladderCanvas" width="800" height="450"></canvas>
    </div>

    <div id="bottomInputs" class="label-grid"></div>
  </div>

  <div class="controls">
    <button class="main-btn" onclick="generateLadder()">ì‚¬ë‹¤ë¦¬ ìƒì„±!</button>
  </div>
</div>

<script>
  const canvas = document.getElementById('ladderCanvas');
  const ctx = canvas.getContext('2d');
  const piece = document.getElementById('playerPiece');

  let state = {
    n: 5,
    h: 15,
    links: [],
    isMoving: false
  };

  // 1. í”„ë¦¬ì…‹ ì ìš©
  function applyPreset(name, count) {
    state.n = count;
    const topWrap = document.getElementById('topInputs');
    const botWrap = document.getElementById('bottomInputs');
    
    topWrap.style.gridTemplateColumns = `repeat(${count}, 1fr)`;
    botWrap.style.gridTemplateColumns = `repeat(${count}, 1fr)`;
    
    // ì…ë ¥ ì¹¸ ìƒì„± (ê¸°ë³¸ê°’ìœ¼ë¡œ ì‚¬ë‹¤ë¦¬ ì´ë¦„ ë„£ê¸°)
    topWrap.innerHTML = '';
    botWrap.innerHTML = '';
    for(let i=0; i<count; i++) {
      topWrap.innerHTML += `<input type="text" value="${name}-${i+1}" id="t${i}" onclick="startFrom(${i})">`;
      botWrap.innerHTML += `<input type="text" value="?" id="b${i}">`;
    }
    
    ctx.clearRect(0,0,canvas.width, canvas.height);
    state.links = []; // ì‚¬ë‹¤ë¦¬ ì„ ì€ ì•„ì§ ì•ˆê·¸ë¦¼
    drawStaticLines();
  }

  // 2. ê¸°ë³¸ ì„¸ë¡œì„  ê·¸ë¦¬ê¸° (ë¹ˆ ì‚¬ë‹¤ë¦¬)
  function drawStaticLines() {
    const w = canvas.width, h = canvas.height;
    const dx = w / (state.n + 1);
    ctx.strokeStyle = "#2b3b55";
    ctx.lineWidth = 3;
    for(let i=1; i<=state.n; i++) {
      ctx.beginPath();
      ctx.moveTo(i*dx, 0);
      ctx.lineTo(i*dx, h);
      ctx.stroke();
    }
  }

  // 3. ì‚¬ë‹¤ë¦¬ ê°€ë¡œì„  ìƒì„± ë° ê·¸ë¦¬ê¸°
  function generateLadder() {
    if(state.isMoving) return;
    const w = canvas.width, h = canvas.height;
    const dx = w / (state.n + 1);
    const dy = h / (state.h + 1);
    
    state.links = Array.from({length: state.h}, () => []);
    
    for(let y=0; y<state.h; y++) {
      for(let x=1; x<state.n; x++) {
        if(Math.random() < 0.5) {
          state.links[y].push(x);
          x++; // ê²¹ì¹¨ ë°©ì§€
        }
      }
    }
    renderAll();
  }

  function renderAll() {
    ctx.clearRect(0,0,canvas.width, canvas.height);
    drawStaticLines();
    const dx = canvas.width / (state.n + 1);
    const dy = canvas.height / (state.h + 1);
    
    ctx.strokeStyle = "#6ee7ff";
    ctx.lineWidth = 4;
    state.links.forEach((row, y) => {
      const yy = (y + 1) * dy;
      row.forEach(x => {
        ctx.beginPath();
        ctx.moveTo(x * dx, yy);
        ctx.lineTo((x + 1) * dx, yy);
        ctx.stroke();
      });
    });
  }

  // 4. ì‚¬ë‹¤ë¦¬ íƒ€ê¸° ë¡œì§ (ë§ ì´ë™)
  async function startFrom(colIdx) {
    if(state.links.length === 0 || state.isMoving) return;
    state.isMoving = true;

    const dx = canvas.width / (state.n + 1);
    const dy = canvas.height / (state.h + 1);
    
    let currentX = (colIdx + 1) * dx;
    let currentY = 0;
    let currentCol = colIdx + 1;

    piece.style.display = 'block';
    updatePiecePos(currentX, currentY);

    // ê²½ë¡œ ê³„ì‚° ë° ì´ë™ ì• ë‹ˆë©”ì´ì…˜
    for(let y=0; y<state.h; y++) {
      // 1. ì•„ë˜ë¡œ ì´ë™
      const targetY = (y + 1) * dy;
      await animatePiece(currentX, targetY);
      currentY = targetY;

      // 2. ì˜†ìœ¼ë¡œ ì´ë™ (ê°€ë¡œì„  ì²´í¬)
      let nextX = currentX;
      if(state.links[y].includes(currentCol)) {
        nextX = (currentCol + 1) * dx;
        currentCol++;
      } else if(state.links[y].includes(currentCol - 1)) {
        nextX = (currentCol - 1) * dx;
        currentCol--;
      }

      if(nextX !== currentX) {
        await animatePiece(nextX, currentY);
        currentX = nextX;
      }
    }

    // ë§ˆì§€ë§‰ ë°”ë‹¥ê¹Œì§€ ì´ë™
    await animatePiece(currentX, canvas.height);
    
    // ê²°ê³¼ ê°•ì¡°
    const resultInput = document.getElementById(`b${currentCol-1}`);
    resultInput.style.backgroundColor = '#6ee7ff';
    resultInput.style.color = 'black';
    setTimeout(() => {
      resultInput.style.backgroundColor = '';
      resultInput.style.color = '';
    }, 2000);

    state.isMoving = false;
  }

  function updatePiecePos(x, y) {
    // ìº”ë²„ìŠ¤ ìœ„ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ë³´ì •
    const rect = canvas.getBoundingClientRect();
    piece.style.left = x + 'px';
    piece.style.top = y + 'px';
  }

  function animatePiece(targetX, targetY) {
    return new Promise(resolve => {
      const startX = parseFloat(piece.style.left);
      const startY = parseFloat(piece.style.top);
      const duration = 200; // ì´ë™ ì†ë„ (ms)
      const startTime = performance.now();

      function step(now) {
        const progress = Math.min((now - startTime) / duration, 1);
        const curX = startX + (targetX - startX) * progress;
        const curY = startY + (targetY - startY) * progress;
        updatePiecePos(curX, curY);

        if(progress < 1) requestAnimationFrame(step);
        else resolve();
      }
      requestAnimationFrame(step);
    });
  }

  // ì´ˆê¸° ë¡œë”© ì‹œ 835(5ê°œ) ê¸°ë³¸ ì ìš©
  window.onload = () => applyPreset('835', 5);
</script>

</body>
</html>
